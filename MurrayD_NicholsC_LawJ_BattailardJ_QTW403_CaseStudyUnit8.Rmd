---
title: "Age Grading: Accounting for Age in Competitive Running"
author: "Dennis Murray, Jared Law, Julien Bataillard, Cory Nichols"
date: "March 6th, 2018"
output:
  word_document:
    fig_caption: yes
section: MSDS 7333-403 - Quantifying the World - Case Study 4 (Unit 8)
---

```{r load_libs, echo=FALSE, include=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(scales)
library(rvest)
library(magrittr)
library(XML)
library(missForest)
library(maps)
library(knitr)
library(png)
library(grid)
```

```{r setup, echo=FALSE, include=FALSE}
dir <- "~/DataScience/SMU/QTW/Unit8/Unit8_CaseStudy/"
setwd(dir)
knitr::opts_knit$set(root.dir = dir)
knitr::opts_chunk$set(echo = FALSE)
```

```{r make, include=FALSE, cache=TRUE, eval=FALSE}
# get and clean data
source("src/make.R")
```

## Abstract

Participation in competitive running has increased dramatically in the past two decades. Simultaneously, the rapid expansion of the Internet has resulted in massive quantities of data now freely available online. Given the appropriate tools, acquiring running data stored on a website is a trivial task. In this paper, we analyze the performance of runners in the Cherry Blossom Ten Mile Run held annually in Washington, D.C. Performance data is acquired by scraping the Cherryblossom.org race result archives for 1999 to 2012. We compare age-normalized race results for 1999 and 2012 men and women. Results show that 1999 runners performed better when using age grading. Furthermore, men typically outperformed women in both years considered.

## Introduction

The sport of running continues to grow rapidly. While major events like the Boston Marathon have held races for more than 100 years, the modern-day sport of running has seen a significant expansion of runner participation since 1995. Overall participation in races around the United States expanded from seven million in 1995 to almost 16 million in 2012 (Running USA 1). 

The Cherry Blossom Ten Mile Run in Washington, D.C. represents a microcosm of the upward participation trend in running. Between the period of 1999 and 2012, participation has tripled. Runners of all ages and skill levels participate in the race each year. 

The objective of any runner is to minimize his or her overall run time. However, age and run times have typically displayed a positive relationship. In order to account for this degradation in performance as participants age, run times are often normalized by the world record time for a given age or age group. This process, known as age grading, is used as a performance standard in competitive running (Nolan, et. al 2).

In this paper, we analyze race results from the Cherry Blossom Ten Mile Run. Results for the 1999 to 2012 period are accessible in HTML tables at Cherryblossom.org. While we explore overall trends and runner characteristics, our objective is to compare the distribution of age-normalized run times for 1999 and 2012. Additionally, we compare gender performance using the same age-normalized run times for both years.

We will review available literature on the topic of running performance and explore overall participation and performance trends from 1999 to 2012. We will discuss the methods used to compare 1999 to 2012 results for men and women and compare results. Our paper will conclude with a discussion of the applications of performance modeling in the increasingly data-driven world of personal fitness.

## Literature Review

Analyzing running performance is a common topic in medical, sports, and evolutionary journals. These studies have been conducted in order to more accurately determine where the human ability for long-distance running originated, how bodies are predisposed to running, and the impact of diet and training on performance.

One of the leading researchers on the subject of runner performance, Dr. Owen Anderson, showed both hereditary and environmental effects contribute to overall runner performance. However, no definitive proof could be given as to the level of impact each had on a runner's performance (Anderson 3).

Further studies have shown that physical predisposition and genetics are major factors affecting running ability. Despite training and environmental factors, it is never enough to fully overcome physiology and the detrimental effects aging has on running ability (Tucker 4). 

Performance in road races and competitive running is bounded by physiological factors. No matter how much diet or training is conducted, harm will come to the athlete who tries to go beyond these limits (Tucker 5,6). This phenomenon is seen in competitive running as a runner ages. Genetic predisposition for efficient oxygen recycling and higher anaerobic thresholds have also been found to enhance runner performance in other studies (Lorenz, et. al 7). 

Ultimately, these studies show the human body has limitations. While there is a net performance gain over time, physiological factors limit human performance.

## Background and Methods

### Data Acquisition Summary

While data acquisition commonly presents itself in the form of reading a flat file, additional measures have to be taken to acquire data from embedded tables on a website. Formatting is often a concern, especially because website data are often surrounded by JavaScript and HTML markers. Luckily, the majority of data required for our analysis came in the form of readily accessible HTML tables stored at different end points on Cherryblossom.org. An example of one such table is seen in Table 1.

```{r read_raw, include=TRUE, echo=FALSE, fig.cap=cap}

knitr::include_graphics("Images/raw_data.png", auto_pdf = FALSE)

cap <- "Table 1: Raw HTML Table for 1999 Male Runners. HTML tables are separated by a line of equals signs that allow for column alignment"
```

Data acquisition from websites, often called "web scraping," is an iterative process. To prepare for data analysis, 28 tables of race results were acquired from Cherryblossom.org. Each table of data represents a year and gender combination. Each table is accessed via a unique web address. The formatting of HTML tables is inconsistent from year to year. In 1999, finish times were represented by a TIME variable. However, in other years, three time variables were presented. Additionally, messy HTML provided for minor difficulties in acquiring 2009 men's race results. We also account for one unrealistic run time and 51 unrealistic or unreported ages.

```{r analysis_data, include=TRUE}
# moved source out of make file to stop iterating over website
# and use files already present
source("src/clean_data.R")

# Combine men and women.  One Dataframe to rule them all.
AllFinishers <- rbind(cbMen, cbWomen)

# the 8 year old is legitimate per running records
# lets change age to <= 7 to be NA, these contain zeros from the
# data cleansing as well as a few odd ages that dont make sense
# only 51 records to drop out of ~146K

AllFinishers <- AllFinishers %>% 
                  mutate(age, age = replace(age, age <= 7, NA))

# only one runner < 30
AllFinishers <- AllFinishers %>% 
                 mutate(runTime, runTime=replace(runTime, runTime <= 30, NA))

# clean up whitespace just because it's obnoxious
AllFinishers[,c("sex","name","home")] <- apply(AllFinishers[,c("sex", "name", "home")], 
                                              2, 
                                              trimws)
# get rid of NAs
AllFinishers <- AllFinishers[complete.cases(AllFinishers),]

# shuffle for better representation sample in viz for paper
AllFinishers <- AllFinishers[sample(nrow(AllFinishers)),]

# create kable with caption
kable(AllFinishers[1:5,], caption="Table 2: Formatted Dataset for Analysis", row.names = FALSE)


```

Year: year of the race
Sex: sex of the runner
Name: Name of the runner
Home: Origin of the runner - home town or country
Age: Age of the runner
RunTime: Run time in minutes

Ultimately, we acquired 28 tables of race results for the 1999 to 2012 time period. While our main objective is to explore differences in only the 1999 and 2012 races, critical contextual information will be presented based on trends over the 14 year period from 1999 to 2012 prior to analysis results. 


### Exploration of Cherry Blossom Ten Mile Race Data, 1999-2012


```{r feature_engineering, include=FALSE}

#Engineer some new features
#Overall Place, Gender Place, Age Group/Gender close

AgeGroupLabels <- c("Under 19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", "60-64", "65-69", "70-79", "80 and up")
AgeThresholds <- c(0, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64, 69, 79, Inf)

AllFinishers <- AllFinishers %>% 
                  mutate(AgeGroup = cut(age, AgeThresholds, AgeGroupLabels)) %>%
                    group_by(year)  %>% 
                      mutate(OverallPlace = rank(runTime, ties.method="first")) %>%
                        group_by(year, sex) %>% 
                          mutate(GenderPlace = rank(runTime, ties.method="first")) %>% 
                            group_by(year, sex, AgeGroup) %>%  
                              mutate(AgeGroupPlace = rank(runTime, ties.method="first")) %>% 
                                data.frame()

```

As stated previously, participation in the Cherry Blossom Ten Mile Run has grown rapidly. While participation by men and women both grew substantially, participation by women played the greatest role in the expansion of the field. Women's participation comprised a minority of 42% in 1999. However, by 2012, women had exchanged positions with men at 57.5% of all participants. The two genders were at parity levels of participation in 2005, and women have since added more than 5,000 participants.

```{r eda_race_size, include=TRUE, fig.width=8.5, fig.height=4}

# What about Total Race Size? And by gender?
AllFinishers %>% 
  group_by(year, sex) %>% 
    summarise(RunnerCount = n()) %>% 
      ggplot(aes(x=year, y=RunnerCount, color=sex)) + 
      geom_line(size=1) + theme_light() + 
      scale_color_manual(values=c("#4286f4", "#fc41e9")) + 
      theme(legend.position = "bottom") + 
      scale_y_continuous( "Total Runners", labels = comma) +
      ggtitle("Figure 1: Cherry Blossom 10 Mile Race - Participants by Gender, 1999-2012") 

```

The age of male runners has declined since 1999, with an average age of 40.3 in 1999, declining to a minimum of 37.8 in 2008. The standard deviation of male ages has consistently hovered between 10 and 12 years.

Women participating in the race, however, have consistently averaged between 33 and 36 years old, without any consistent trend year over year. Standard deviation of age for women is about nine years.

```{r eda_age_trends, include=TRUE, echo=FALSE, fig.width=8.5, fig.height=4}

# Have participants ages changed signficantly?
# set up viz to take a look at ages and finishes
AllFinishers %>%  
  ggplot(aes(x=as.factor(year), y=age, color=sex)) + 
  geom_boxplot() + 
  theme_light() + 
  scale_color_manual(values=c("#4286f4", "#fc41e9")) + 
  theme(legend.position = "none") + 
  scale_y_continuous("Age") +
  ggtitle("") + 
  scale_x_discrete("Year") + 
  ggtitle("Figure 2: Distribution of Age for Runners, 1999-2012") + 
  facet_wrap(~sex, ncol=1)
```

The finish time for the best male participant for this ten mile event has improved consistently from 2008 to 2012, with times approaching 45 minutes. Based on the correlation between age and performance, the improvement in men's times could be a result of the decrease in the average age for men. Women's times have been more static, with the exception of a 4 year run of times from 2004 to 2007. 

```{r eda_gender_place, include = TRUE, fig.width = 8.5, fig.height = 4}
# set up gender top finishes viz, show trend over time
AllFinishers %>% 
  filter(GenderPlace==1) %>% 
    mutate(year=as.factor(year)) %>%
      ggplot(aes(x=year, y=runTime, group=sex, color=sex)) + 
      geom_point() + 
      geom_line() + 
      theme_light() + 
      scale_color_manual(values=c("#4286f4", "#fc41e9")) + 
      theme(legend.position = "bottom") + 
      scale_y_continuous("Time In Minutes") + 
      ggtitle("Figure 3: Fastest Time By Race Year and Gender")
```

Examination of race finish times by age groups and gender show several general consistencies. The first is the consistency in most age groups from year to year of the race. Most age groups can be described as a "random walk" around a median race time, with the exception of the 20-24 year segment for men showing a consistent reduction of race finishing times year over year. The Under 19 segment shows a high degree of variation in the winning runner's time. Some degree of this variability might be explained by the number of participants in the segment- consistently less than 100 in each gender- as well as progression of these runners into the more elite 20-24 age group. The two age divisions for ages 65 and over are omitted from the visualization.

```{r eda_age_groups, include = TRUE, fig.width = 8.5, fig.height = 4}

# set up age group viz, show finishes over time
AllFinishers %>% 
  filter(AgeGroupPlace==1) %>% 
    mutate(year=as.factor(year)) %>% 
      filter(age<=64 & age != 0) %>%
        ggplot(aes(x=year, y=runTime, group=sex, color=sex)) + 
        geom_point() + 
        geom_line( ) + 
        theme_light() + 
        scale_color_manual(values=c("#4286f4", "#fc41e9")) + 
        facet_wrap(~AgeGroup, ncol=5) + 
        theme(legend.position="bottom") + 
        scale_x_discrete(labels=c())+
        ggtitle("Figure 4: Age Group Top Performances by Year")
```

There may also be some inference made about sudden changes in the winning times for age groups.  The increase of the winning time in the 30-34 age group in the 2011 and 2012 races could signal a key competitor has aged out of the group. Indeed, we see the 35-39 age group for men taking a sudden drop in winning time in 2011 and 2012. While the race size overall is large, there could be a few elite competitors that set the pace for most of the age groups.

Examination of Figure 5 allows for another inference regarding the relationship between age and run time. The visualizations show the fastest running time for every age between 20 and 80 by gender. Excluding the youngest and oldest participants from our research, running times for men peak in the early twenties, with steadily increasing times for the rest of life. Women peak closer to thirty, with times slowing through their thirties and forties. Both genders' run times display non-linear relationships when considering age, especially as age increases.

```{r eda_lead_runners, include = TRUE, echo = FALSE, fig.height=4, fig.width=8.5}

# get top finishers and best times
TopFinisher <- AllFinishers %>% 
                group_by(age, sex, year) %>% 
                  mutate(BestInAgeTime = min(runTime), WorstInAgeGroup = max(runTime)) 

BestTimeYr <- AllFinishers %>% 
                group_by(age, sex) %>% 
                  summarise(BestInAgeTime = min(runTime))

# plot best times
BestTimeYr %>% 
  filter(age %in% (20:80)) %>%
    ggplot(aes(x=age, y=BestInAgeTime, group=sex, color=sex)) + 
    geom_line() + 
    theme_light() + 
    scale_color_manual(values=c("#4286f4", "#fc41e9")) + 
    facet_wrap(~sex) + 
    #geom_smooth(method="loess") + 
    theme(legend.position = "bottom") + 
    ggtitle("Figure 5: Fastest Time by Age and Gender") + 
    scale_x_continuous(limits=c(20,80)) + 
    scale_y_continuous("Best Performance by Age")
```


### Controlling for Age in Competitive Race Results

The relationship between age and performance is a natural phenomenon known well by competitive runners. To account for this phenomenon, age grading is used for ranking runners performance based on their age. In fact, age graded performance is more frequently used for runner comparisons. Runnersworld.com describes age grading as "a way of putting all race participants on a level playing field, regardless of age or gender. (3)" In age grading, a runner's time is normalized based on the world record time for his or her age. To normalize run times, analysis typically involves dividing raw run times by the world record for a given age. As an example, a runner who is 33 with a finish time of 75 minutes would have a standardized time of (75/57) 1.32 given a record time of 57 minutes for his age category. We use the terms age grading and normalization interchangeably for the remainder of this paper.

Given overwhelming visual evidence of the positive relationship between age and running performance, we implement an age grading method to compare the 1999 results to the 2012 race results for the Cherry Blossom Ten Mile Run. Top runners in the Cherry Blossom races have run very close to world records. Therefore, we use the fastest times for each age in the dataset containing race results from 1999 to 2012. Typically, we would use the actual fastest run times for each age to normalize raw run times. However, year-to-year fluctuations of fastest times given age call for a different approach.

To account for run time fluctuations, we gather the fastest times for each age predicted by a LOESS model. LOESS is a non-parametric local regression method that uses subsets of data to fit individual regression models across an explanatory variable range. This method allows for complex curve fitting. In our case, it takes some of the noise out of the run times we use for age grading. We fit the LOESS model to the dataset containing the fastest run times and age, using run time as the response. We subsequently predict fastest run times for each age given our fitted model. The resulting predictions then represent smoothed fastest times to be used for normalization. The predictions for fastest times given age are represented by the black line for both genders in Figure 6. LOESS has effectively smoothed the fastest run times used for age grading.

``` {r loess_setup, include = FALSE}

# split base datasets for gender analysis purposes

# when we use approximate world record times to smooth, we
# must consider very young ages: these are typically not tracked and
# are extremely sparse, they do not make sense to maintain in analysis
# e.g. the one 8 year old is not representative of the world record for his age
# this also is the case for older people > 80 (even really after 60)
# instead, consider ages 12 to 80, where we have at least 20 records over years
# consider 12 as low bound because 10m race is restricted to 12 and above
# older ages > 80 are too sparse to be reliable

AllFinishers <-  AllFinishers[(AllFinishers$age>=12 & AllFinishers$age<=80),]
AllFinishersM <- AllFinishers[AllFinishers$sex == "M",]
AllFinishersW <- AllFinishers[AllFinishers$sex == "W",]

# get best times for both men and women to use in LOESS smoothing
BestTimes <- AllFinishers %>%
              group_by(sex, age) %>%
                summarise(fastest=min(runTime))

BestTimesM <- BestTimes[BestTimes$sex == "M",]
BestTimesW <- BestTimes[BestTimes$sex == "W",]
```

``` {r loess_smooth, include=TRUE, fig.width=8.5, fig.height=4}
# smooth data
# use span of 0.25 instead of .75 to capture curvature better
RunModelMen <- loess(fastest ~ age, data=BestTimesM, span=0.25)
RunModelWomen <- loess(fastest ~ age, data=BestTimesW, span=0.25)

# smooth times out, returns vector of times for each age, use all ages
PredictedTimeM <- predict(RunModelMen, newdata = BestTimesM$age)
PredictedTimeW <- predict(RunModelWomen, newdata = BestTimesW$age)

# bind up predictions for use in viz
predTimes<-rbind(data.frame(predicted=PredictedTimeM),
                 data.frame(predicted=PredictedTimeW))

# plot smooth vs rough times
cbind.data.frame(BestTimes, predTimes) %>% 
  ggplot(aes(x=age)) + 
  geom_line(aes(y=fastest, group=sex, color=sex), size=1, alpha = 0.5) +
  geom_line(aes(y=predicted, color=" Predicted")) +
  theme_light() + 
  ggtitle("Figure 6: Fastest Race Times with Smoothing Using LOESS") + 
  scale_x_continuous("Age") + 
  scale_y_continuous("Run Time in Minutes") +
  facet_wrap(~sex)+
  scale_color_manual(values=c("black", "#4286f4","#fc41e9"))+
  theme(legend.position="bottom", 
        legend.title=element_blank())
```

We use the predicted values to normalize the raw 1999 and 2012 race results. The Cherry Blossom Race requires all ten mile runners to be at least 12 years old and data for individuals older than 80 is extremely sparse. Therefore, only run times for ages greater than 11 and less than 81 are considered. To control for gender-based performance differences, we separate age grading for men and women. We explore the results of implementing age grading using LOESS in the next section.

## Results of Age Grading Analysis

LOESS regression predictions allow us to compute age normalized run times for men and women that entered the 1999 and 2012 Cherry Blossom Ten Mile Run races. We first explore individual gender results for both years considered. We then compare the two genders to determine which performed better.

#### Comparing Men's Run Times for 1999 and 2012

When naïvely comparing median results, runners in 1999 underperform (92.65) relative to runners in 2012 (92.42). This comparison does not account for the age distribution of runners in the field. Given our age grading implementation, we compare both years accounting for age. 

```{r men_1999v2012, fig.width=8.5, fig.height=4}

# normalize all times based on fastest time predictions per instructions
names(PredictedTimeM) = BestTimesM$age
timeNormM = AllFinishersM$runTime / PredictedTimeM[as.character(AllFinishersM$age)]

# pull out two years we are interested in for the men
time99NormM = timeNormM[AllFinishersM$year == 1999]
time12NormM = timeNormM[AllFinishersM$year == 2012]


#summary(time99NormM)
#summary(time12NormM)

# combine normalized times
AllNormTimes<-data.frame(age=names(time99NormM), 
                         year="1999",
                         NormRunTime=time99NormM)

AllNormTimes<-rbind(AllNormTimes, 
                    data.frame(age=names(time12NormM), 
                               year="2012", 
                               NormRunTime=time12NormM))

AllNormTimes %>% 
          ggplot(aes(x=NormRunTime, color=year, group=year)) + 
          geom_density(size=1) + 
          theme_light() + 
          theme(legend.position = "bottom") + 
          ggtitle("Figure 7: Density of Normalized Run Time - Men, 1999 vs. 2012", 
                    subtitle = "Run Times Normalized by Fastest Predicted Time (LOESS) for All Race Years")

# 2012 age controlled times are definitely slower, 
# runners generally ran slower for their age grps

# check QQ plot for 1999 vs 2012 Men
df <- as.data.frame(qqplot(time99NormM, time12NormM, plot.it = FALSE))

ggplot(df) + 
          geom_point(aes(x=x, y=y))+
          geom_abline(aes(intercept=0, slope=1, col="red"), show.legend = FALSE)+
          theme_light() + 
          ggtitle("Figure 8: QQ Plot of Age Graded Times for Men") + 
          scale_x_continuous("Age Normalized Time - 1999") + 
          scale_y_continuous("Age Normalized Time - 2012") + 
          theme(legend.position="bottom", 
                legend.title=element_blank())
```

Reviewing the density plot in Figure 7, the 1999 participants age graded run times are shown to be centered just above 1.63 times the fastest runner's time. 2012 is centered closer to 1.75 times the fastest runner's time. 2012 also exhibits a wider, flatter curve with a less prominent median. Additional evidence for slowness in 2012 can be clearly seen in Figure 8. The QQ plot shows a pull toward 2012, especially for runners in slower quartiles. These two distributions are obviously not the same and indicate that, when accounting for age, 1999 runners performed better than 2012 runners.

As mentioned in the previous section, the number of runners in the 2012 race has increased significantly. However, we also see a clear shift towards a larger median. This might signal that the growth of the race's field is mostly in the recreational category of runner- a casual athlete, as well as persons seeking to walk the race route. The second statement seems well supported by the long tail distribution of 2012 runners. In 1999, the race effectively cut-off at the 2.5 times the best runner's time, while in 2012 the race extended beyond three times the best runner's time. We could infer that the added participation is largely in mid-pack and lower runners, and not in the faster part of the men's field.

```{r men_t, eval=FALSE}
# t test show sig difference with 1999 being faster when accounting for age
t.test(time99NormM, time12NormM)

```

In fact, male runners in 1999 were found to have a statistically significant difference from male runners in 2012 in the normalized for age run time. Runners in 1999 were a mean of 0.12 faster than in 2012 (p<0.0001). This result differs from the conclusions resulting from naïvely comparing median run times given at the beginning of this section. 


#### Comparing Women's Run Times for 1999 and 2012

We also compare women's run times between 1999 and 2012 using the same age grading technique. As previously seen in Figure 6, times for women show sharp curvature. Peak run times occur around age 30, and then increase sharply. Of particular note is the amount of run time variation for women in their late 70s. LOESS helps to smooth this variation when using age grading.


``` {r women_1999v2012, fig.width=8.5, fig.height=4, include=TRUE}

# normalize all times based on fastest time predictions per instructions
names(PredictedTimeW) = BestTimesW$age
timeNormW = AllFinishersW$runTime / PredictedTimeW[as.character(AllFinishersW$age)]

# pull out two years we are interested in
time99NormW = timeNormW[AllFinishersW$year == 1999]
time12NormW = timeNormW[AllFinishersW$year == 2012]

#summary(time99NormW)
#summary(time12NormW)

# combine normalized times
AllNormTimes<-data.frame(age=names(time99NormW), 
                         year="1999",
                         NormRunTime=time99NormW)

AllNormTimes<-rbind(AllNormTimes, 
                    data.frame(age=names(time12NormW), 
                               year="2012", 
                               NormRunTime=time12NormW))
# plot density
AllNormTimes %>% 
          ggplot(aes(x=NormRunTime, color=year, group=year)) + 
          geom_density(size=1) + 
          theme_light() + 
          theme(legend.position = "bottom") + 
          ggtitle("Figure 9: Density of Normalized Run Time - Women, 1999 vs. 2012", 
                    subtitle = "Run Times Normalized by Fastest Predicted Time (LOESS) for All Race Years")


# check QQ plot for additional comparisons
df <- as.data.frame(qqplot(time99NormW, time12NormW, plot.it = FALSE))

ggplot(df) + 
          geom_point(aes(x=x, y=y))+
          geom_abline(aes(intercept=0, slope=1, col="red"), show.legend = FALSE)+
          theme_light() + 
          ggtitle("Figure 10: QQ Plot of Age Graded Times for Women") + 
          scale_x_continuous("Age Normalized Time - 1999") + 
          scale_y_continuous("Age Normalized Time - 2012") + 
          theme(legend.position="bottom", 
                legend.title=element_blank())

```


Comparing the results of women's times from 1999 and 2012 reveals less of a difference than we saw for the men. However, 2012 results are very similar to those of the men, with a wider distribution and flatter center of age graded run times. The median run time increases from 1.73 to 1.78, and the mean from 1.72 to 1.80.  The interquartile range has also expanded from 0.33 to 0.38.  

As seen in the previous section, the increase in female participants expanded dramatically. The distributions of women's normalized run times for 1999 and 2012 are more similar than the distributions for men. While additional results have been added to the tail of the distribution, the overall length of the distribution has not changed in the same manner that the men's times have. The maximum race length is still about three times the first finisher for each age group.

Inspecting the quantile-quantile plot provides additional clarity. Similar to the men, results for women in 2012 tend to pull upward from the distribution of 1999 results. This indicates 2012 slightly underperformed 1999 for the women participants. Given these distributions are so close, we also formally compare them with a two-sample *t*-test.

```{r women_t, include=FALSE, eval=FALSE}
# t test show sig difference with 1999 being faster when accounting for age
t.test(time99NormW, time12NormW)
```

A two-sample student's *t*-test finds a significant difference in the mean for the two years of women's race results. While there was a similar normalized median, the difference of normalized mean running times is approximately 0.07 (p<0.0001), indicating the 1999 field was faster given age graded run times. Naïvely comparing run times with no age grading also shows women in 1999 outperform women in 2012.


#### Comparing Age Graded Run Times Across Genders

Age graded run times differ when comparing 1999 results to 2012 results for the same gender. In this section we explore gender comparisons directly. We test men's age graded run times against women's age graded run times in the Cherry Blossom Ten Mile Run for 1999 and 2012.

##### Results for 1999

Density and quantile-quantile plots are given for the 1999 field of runners in Figures 11 and 12.

``` {r womenvmen_1999, fig.width = 8.5, fig.height=4, include=TRUE}

AllNormTimes<-data.frame(age=names(time99NormM), 
                         year="1999", 
                         sex="M", 
                         NormRunTime=time99NormM)

AllNormTimes<-rbind(AllNormTimes, 
                    data.frame(age=names(time99NormW), 
                               year="2012", 
                               sex="F",
                               NormRunTime=time99NormW))

AllNormTimes %>% 
  ggplot(aes(x=NormRunTime, color=sex, group=sex)) + 
  geom_density(size=1) + 
  theme_light() + 
  theme(legend.position = "bottom") + 
  scale_color_manual(values=c("#4286f4","#fc41e9"))+
  ggtitle("Figure 11: Density of Normalized Run Times - Men vs. Women in 1999")

df <- as.data.frame(qqplot(time99NormM, time99NormW, plot.it = FALSE))

ggplot(df) + 
          geom_point(aes(x=x, y=y))+
          geom_abline(aes(intercept=0, slope=1, col="red"), show.legend = FALSE)+
          theme_light() + 
          ggtitle("Figure 12: QQ Plot of Age Graded Times for Men and Women - 1999") + 
          scale_x_continuous("Age Normalized Time - Men") + 
          scale_y_continuous("Age Normalized Time - Women") + 
          theme(legend.position="bottom", 
                legend.title=element_blank())

```

In 1999, we can infer that the performance of the men's field is more closely aligned to the elite portion of their field than the women's field is to their elite competitors. The median male performance is 1.63 times the run time of the first place finisher for their age, while females are above 1.72 times. While men seem to be faster when accounting for age, a stronger right skew can be seen in their density curve in Figure 10. This plays out more apparently when investigating the quantile-quantile plot in Figure 12 of men's versus women's 1999 run times. This right skew implies that men had more extreme slow runners than women. However, these slow runners do not make up for the significant performance gap for fast runners seen on the left side of the density plot.


````{r gender_t_99, include=FALSE, eval=FALSE}
# men age controlled outperform women in 99
t.test(time99NormM, time99NormW)
```

A two-sample student's *t*-test shows a statistically significant difference of the mean relative performance of men and women. Men are 0.07 faster than women (p<0.0001) when comparing age graded results for 1999.

##### Results for 2012

Density and quantile-quantile plots are given for the 2012 field of runners in Figures 13 and 14.

```{r womenvmen_2012, fig.width=8.5, fig.height=4, include=TRUE}

# prep underlying data for viz - 2012
AllNormTimes<-data.frame(age=names(time12NormM), 
                         year="2012", 
                         sex="M", 
                         NormRunTime=time12NormM)

AllNormTimes<-rbind(AllNormTimes, 
                    data.frame(age=names(time12NormW), 
                               year="2012", 
                               sex="F", 
                               NormRunTime=time12NormW))

# plot density
AllNormTimes %>% 
  ggplot(aes(x=NormRunTime, color=sex, group=sex)) + 
  geom_density(size=1) + 
  theme_light() + 
  scale_color_manual(values=c("#4286f4","#fc41e9"))+
  theme(legend.position = "bottom") + 
  
  ggtitle("Figure 13: Density of Normalized Run Times - Men vs. Women in 2012")


# plot QQ, get raw data first and pass to ggplot
df <- as.data.frame(qqplot(time12NormM, time12NormW, plot.it = FALSE))

ggplot(df) + 
          geom_point(aes(x=x, y=y))+
          geom_abline(aes(intercept=0, slope=1, col="red"), show.legend = FALSE)+
          theme_light() + 
          ggtitle("Figure 14: QQ Plot of Age Graded Times for Men and Women - 2012") + 
          scale_x_continuous("Age Normalized Time - Men") + 
          scale_y_continuous("Age Normalized Time - Women") + 
          theme(legend.position="bottom", 
                legend.title=element_blank())
```

Reviewing the density curves for 2012, the age graded men's performance has shifted to be very similar to the women's. The distribution of the women has a more narrow interquartile range than the men. Men's median age grade performance for 2012 is 1.75 while women's is 1.79, indicating men performed slightly better when accounting for age in 2012. Similar to 1999, men's results have a larger right tail. This can be seen in the quantile-quantile plot in Figure 14. The performance gap for the fastest runners between genders is not as large as in 1999. This is represented by the smaller space between the pink and blue lines on the left side of the density plot. However, this gap is still large enough to give men a slight edge in run times when considering age. We formally test differences in mean age graded run times.


```{r gender_t_12, include=FALSE, eval=FALSE}
# much closer for 12, but men slightly outperform
t.test(time12NormM, time12NormW)
```

The two-sample student's *t*-test again finds a significant difference between men's and women's relative times; however, this time the performance gap has narrowed. Men still run a faster time relative to their age and gender, with a mean time of 1.77 times fastest time, while women run a mean time of 1.80 times their age and gender's fastest time. This is still a statistically significant difference (p<0.0001).


## Future Work and Conclusions

The comparison of the results of the Cherry Blossom Ten Mile Race between 1999 and 2012 has led to several interesting insights. As seen for the 1999 versus 2012 men's results, accounting for age can result in different conclusions when comparing two race fields. In this example, age grading does level the playing field. Overall, results show that 1999 runners typically perform better than 2012 runners. Additionally, men outperform women. However, the gender gap in age graded performance is closing. The women's field in 2012 performed almost as well as the men.

Before exploring applications, one point of caution must be addressed. The exploration of field size for 1999 and 2012 clearly shows an exponentially increasing level of popularity for competitive running. The 1999 Cherry Blossom Ten Mile Run field was significantly smaller than the 2012 field. With rising popularity, additional considerations need to be investigated to objectively compare running performance. For example, more casual runners and walkers now enter into competitive races. Obviously, this change in demographics could easily bias our earlier comparisons. It is worth investigating a skill level effect as part of age graded analysis to control for potential bias.

The sport of running, and this event specifically, have seen rapid expansion for a 13 year time period, with a substantially higher interest in the event from women. Women's interest in running as a sport has led to the creation of all-female events like the Disney Princess events. There has also been an expansion of women's running product lines from many brands, with a shifting strategy towards brands that cater exclusively to female athletes and runners.

The event has also moved toward higher participation by mid-pack athletes and walkers. Race organizers should ensure their race is well organized and still well supported for longer durations. In consideration of these athletes, there may be a need for greater, or different medical support services throughout the course and at the finish line. These athletes are also likely the best audience for many race sponsors.

Application of predictive timing in running and other endurance sports holds numerous applications.

The running community holds the integrity of their sport in highest regard. This has spurred a cottage industry of people who attempt to expose people who may be taking unethical steps to improve their race times. This varies from people not following the selected course (either via a cut through or non-foot transportation), as well as people using surrogates carrying their bib to help qualify for prestigious races like the Boston Marathon. Much of this research has been powered via the published results on race websites, as well as aggregator active.com. The researchers have largely looked for suspicious results on a one-by-one basis, but a LOESS-based model based on age using multiple years' results could lend new insight to questionable results.

Likewise, race organizers could benefit from deeper insight into their event for practical purposes. Race organizers must first schedule road closures with municipal authorities to ensure a safe course for participants. Understanding the age distribution, and the predicted finish times for their participants, might reduce the chances that a runner is not allowed to finish the race due to slow running times. Additionally, race logistics like start waves are also dependent on expectation of the time required for a specific runner to finish the race. While in most large races this is done on a seeding based on prior finishing times for the same distance, or expected finishing time based on other distances, unknown runners could be added to other groups based on a calculated race finishing time based on age.

Fitness devices and smart phone applications for fitness have become a standard for recreational runners. Predictive pacing could hold a competitive advantage to a device that helps an athlete train smarter.


## References
1. “U.S. Road Race Trends.” Running USA, 23 Mar. 2017, www.runningusa.org/2017-us-road-race-trends.

2. Nolan, D., Temple Lang, D. DATA SCIENCE IN R: a Case Studies Approach to Computational Reasoning and Problem Solving. CRC PRESS, 2017.

3. Anderson, Owen. “Running Science”, HumanKinetics.com, http://www.humankinetics.com/excerpts/excerpts/genes-and-running-performance.

4. Tucker, R. “The Anticipatory Regulation of Performance: The Physiological Basis For Pacing Strategies And The Development Of A Perception-Based Model For Exercise Performance.”, British Journal of Sports Medicine, June 2009.

5. Tucker R., Noakes TD. “The Physiological Regulation of Pacing Strategy During Exercise: A Critical Review.”, British Journal of Sports Medicine, June 2009.

6. Joyner, M. J., “Modeling: Optimal Marathon Performance on The Basis Of Physiological Factors.”, Journal of Applied Physiology, Feb 1991.

7 . Lorenz, Daniel S., et al. “What Performance Characteristics Determine Elite Versus Nonelite Athletes in the Same Sport?” Sports Health, SAGE Publications, 5 Nov. 2013, www.ncbi.nlm.nih.gov/pmc/articles/PMC3806174/.

8.	"Age Grade Calculator." Runner's World, 22 Sept. 2017, www.runnersworld.com/tools/age-grade-calculator.


# APPENDIX - BOOK CODE

``` {r eda_old, include=FALSE, eval=FALSE}

# overplotting issues
plot(runTime ~ age, data = cbMen, ylim = c(40, 180),
     xlab = "Age (years)", ylab = "Run Time (minutes)")

# use color brewer to clean up overplotting
library(RColorBrewer)
ls("package:RColorBrewer")

# display help with colors
display.brewer.all()

Purples8 = brewer.pal(9, "Purples")[8]

# returns RBG hex
Purples8

# append alpha
Purples8A = paste(Purples8, "14", sep = "")

# plot with purple alpha, notice upward curbe in times as age increases
plot(runTime ~ jitter(age, amount = 0.5), 
     data = cbMen, 
     pch = 19, cex = 0.2, col = Purples8A,
     ylim = c(45, 165), xlim = c(15, 85),
     xlab = "Age (years)", ylab = "Run Time (minutes)")

# plot histogram
hist(cbMen$runTime)
library(e1071) 
skewness(cbMen$runTime) # right skew

# smooth density representation of scatter plot using color
# uses statistical techniques to building regions that vary by color
# color at (x,y) location is determined by density of points in a small region around the point
# average them, yields smoother plot with dark shades == high density

# represent dense data more efficiently:
smoothScatter(y = cbMen$runTime, x = cbMen$age,
              ylim = c(40, 165), xlim = c(15, 85),
              xlab = "Age (years)", ylab = "Run Time (minutes)")

# display summary statistics of run time for subgroups of runners with roughly same age
# remove outlier runners
cbMenSub = cbMen[cbMen$runTime > 30 &
                 !is.na(cbMen$age) & cbMen$age > 15
                 & cbMen$age != 0, ]

# cut data into different categories for ages (15 to 90 by 10s)
ageCat = cut(cbMenSub$age, breaks = c(seq(15, 75, 10), 90))
table(ageCat)

# can easily make out increases in time based on age!
plot(cbMenSub$runTime ~ ageCat, 
     xlab = "Age (years)", ylab = "Run Time (minutes)")

```
```{r lm_avg_performance, include=FALSE, eval=FALSE}

# fit a simple linear regression model
lmAge = lm(runTime ~ age, data = cbMenSub)

# positive coefficient for age as expected
lmAge$coefficients

# age is significant in the model, r squared is terrible, doesnt describe variance
# can see the line doesnt model 1Q and 3Q of data well, median is closer
summary(lmAge)

class(lmAge)

# we plot the residuals against age to see how this line fits
# can call residuals data from list returned via lmAge
smoothScatter(x = cbMenSub$age, y = lmAge$residuals,
              xlab = "Age (years)", ylab = "Residuals")
abline(h = 0, col = "purple", lwd = 3)
 
# fit locally weighted curve to the data to discern patterns
resid.lo = loess(resids ~ age, 
                 data = data.frame(resids = residuals(lmAge),
                                   age = cbMenSub$age))

# predict average residual for each year of age
age20to80 = 20:80

# predict locally fitted values from 20 to 80
resid.lo.pr = 
  predict(resid.lo, 
          newdata = data.frame(age = age20to80))

# plot LOESS predictions for residuals
# can easily see non-linear relationship as LOESS curves up as age increases
# lin reg does a poor job modeling curvature in runtime given age for older men
lines(x = age20to80, 
      y = resid.lo.pr, 
      col = "green", 
      lwd = 2)


# fitting a more complex model to predict runTime
# LOESS
menRes.lo = loess(runTime ~ age, cbMenSub)
menRes.lo.pr = predict(menRes.lo, data.frame(age = age20to80))

# Piecewise Linear Model with different segments
# allows us to bend the line at certain points
# hinge at 30,40,50,60

# consider one hinge at over 50
# coefficient c for over50 is change in slope from below 50 to above 50 and intercept makes segs
# connect
over50 = pmax(0, cbMenSub$age - 50) # zero out anything 50 and under and use this var in lm() call
lmOver50 = lm(runTime ~ age + over50, data = cbMenSub)

summary(lmOver50)

# create hingest
decades = seq(30, 60, by = 10)
# get a list of numeric vectors for each hinge for the piecewise regression equation
overAge = lapply(decades, 
                 function(x) pmax(0, (cbMenSub$age - x)))
names(overAge) = paste("over", decades, sep = "")
overAge = as.data.frame(overAge)
tail(overAge)

# now create piecewise model
lmPiecewise = lm(runTime ~ . , # include all covariates except for run time in DF
                 data = cbind(cbMenSub[, c("runTime", "age")], 
                              overAge)) # bind hinge variables

# over 60 not different from over 50
summary(lmPiecewise)

# how do we plot? use predict, but must set up data to fit model
overAge20 = lapply(decades, function(x) pmax(0, (age20to80 - x)))
names(overAge20) = paste("over", decades, sep = "")
overAgeDF = cbind(age = data.frame(age = age20to80), overAge20)

tail(overAgeDF)

predPiecewise = predict(lmPiecewise, overAgeDF)


# plot two methods against one another
plot(predPiecewise ~ age20to80,
     type = "l", col = "purple", lwd = 3,
     xlab = "Age (years)", ylab = "Run Time Prediction")

lines(x = age20to80, y = menRes.lo.pr, 
      col = "green", lty = 2, lwd = 3)

legend("topleft", col = c("purple", "green"),
       lty = c(1, 2), lwd= 3,
       legend = c("Piecewise Linear", "Loess Curve"), bty = "n")

# piecewise not able to capture over 70 because we didnt hinge on it

```
``` {r runner_composition, include=FALSE, eval=FALSE}
numRunners = with(cbMen, tapply(runTime, year, length))
# number of runners more than doubled from 1999 to 2012
plot(numRunners ~ names(numRunners), type="l", lwd = 2,
     xlab = "Years", ylab = "Number of Runners")


# look at summary stats from beginning and 2012
summary(cbMenSub$runTime[cbMenSub$year == 1999])
summary(cbMenSub$runTime[cbMenSub$year == 2012])


age1999 = cbMenSub[ cbMenSub$year == 1999, "age" ]
age2012 = cbMenSub[ cbMenSub$year == 2012, "age" ]

# plot density curves for ages in '99 and '12
# age distributions are definitely different
plot(density(age1999, na.rm = TRUE), 
     ylim = c(0, 0.05), col = "purple",
     lwd = 3,  xlab = "Age (years)",  main = "")

lines(density(age2012, na.rm = TRUE), 
      lwd = 3, lty = 2, col="green")

legend("topleft", col = c("purple", "green"), lty= 1:2, lwd = 3,
       legend = c("1999", "2012"), bty = "n")

# both sets did not come from the same distribution, line is not straight
# it's close but not exact
qqplot(age1999, age2012, pch = 19, cex = 0.5, 
       ylim = c(10,90), xlim = c(10,90), 
       xlab = "Age in 1999 Race",
       ylab = "Age in 2012 Race", 
       main = "Quantile-quantile plot of male runner's age")
abline(a =0, b = 1, col="red", lwd = 2)


# smooth curves (LOESS) for 99 and 12
mR.lo99 = loess(runTime ~ age, cbMenSub[ cbMenSub$year == 1999,])
mR.lo.pr99 = predict(mR.lo99, data.frame(age = age20to80))

mR.lo12 = loess(runTime ~ age, cbMenSub[ cbMenSub$year == 2012,])
mR.lo.pr12 = predict(mR.lo12, data.frame(age = age20to80))


plot(mR.lo.pr99 ~ age20to80,
     type = "l", col = "#984ea3", lwd = 3,
     xlab = "Age (years)", ylab = "Prediction (minutes)")  
lines(x = age20to80, y = mR.lo.pr12, col="#4daf4a", lty = 2, lwd = 3) 

legend("topleft", col = c("#984ea3", "#4daf4a"), lty = 1:2, lwd = 3,
       legend = c("1999", "2012"), bty = "n")


# plot differences in curves, 2012 was slower in general
gap14 = mR.lo.pr12 - mR.lo.pr99

plot(gap14 ~ age20to80, type = "l" , xlab = "Age (years)", 
     ylab = "Difference in Fitted Curves (minutes)", lwd = 2)
```
``` {r case_analysis, include=FALSE, eval=FALSE}
# EXTRA CREDIT
# imputation with random forest missForest
# replace ages < 10, 10M is for 13 and up, likely errors

# impute instead of toss out, take different approach than authors
# Lidiya Grigoryeva is an example

all_runners <- rbind(cbMen, cbWomen)

# did some google research here, these youngins are for real!!!
# lets change age to <=5, 
all_runners <- all_runners %>% 
                mutate(age, 
                 age=replace(age, age <= 5, NA))

# only one runner < 30, but let's impute
all_runners <- all_runners %>% 
                mutate(runTime, 
                 runTime=replace(runTime, runTime <= 30, NA))

# shuffle
all_runners <- all_runners[sample(nrow(all_runners)),]

# which did we null out for age?
nulls <- which(is.na(all_runners$age))

# clean up whitespace just because it's obnoxious
all_runners[,c("sex","name","home")] <- apply(all_runners[,c("sex", "name", "home")], 
                                              2, 
                                              trimws)

     
# prep for imputation, if we really wanted to get sexy here we 
# could cut VAR on country, obvious indicator for runTime and age, tried this and countries are MESSY
# dont have enough time to complete this extra task + that extra task 
all_runners_imp <- all_runners[,c("age","runTime", "year","sex")]

# this doesnt matter unless we do agg analysis including women
# call binary indicator to speed up imputation process a bit
all_runners_imp <- all_runners_imp %>% 
                   mutate(sex = ifelse(sex == "W", 1, 0 ))


# non parametric impute using random forest imputer
# reduce number of trees for time purposes, accuracy trade off not much diff
set.seed(42)
impute_object <- missForest(all_runners_imp, 
                            ntree = 50, 
                            maxiter = 3,
                            variablewise = FALSE,
                            verbose = FALSE)

# all numeric, small normalized RMSE
impute_object$OOBerror 

# get imputed features and round age predictions
all_runners_imp <- impute_object$ximp
all_runners_imp$age <- round(all_runners_imp$age)

# column bind other features not included in impute
# to re-create full data set
all_runners_imp <- cbind(all_runners[, c("sex","name","home")],
                         all_runners_imp[,-4] )

# what does imputation look like for age?
all_runners_imp[which(is.na(all_runners$age)),]

# separate men and women into imputed datasets for analysis
cbMen_imp = all_runners_imp[all_runners_imp$sex=="M",]
cbWomen_imp = all_runners_imp[all_runners_imp$sex=="W",]

# start men's analysis
fastestMen = tapply(cbMen_imp$runTime, 
                    cbMen_imp$age,
                    min, 
                    na.rm = FALSE) # we imputed here instead

# convert to numeric
age_fastest_men = as.numeric(names(fastestMen))
# smooth fastest times by fitting and predicting LOESS
# reduce LOESS span, get significant curve up in age
# consider kids < 12 yrs old
table(cbMen_imp$age) # too few obs when considering < 12 and > 80

mens_fast_lfit = loess(fastestMen ~ age_fastest_men, span=0.5)
mens_fast_lpred = predict(mens_fast_lfit, data.frame(age = age_fastest_men), se = FALSE)
plot(fastestMen ~ names(fastestMen), type ="l", xlim = c(20, 80))
lines(x = age_fastest_men, y = mens_fast_lpred, col = "purple", lwd = 2)

# normalize times - index on cbMen$age
# ensure predictions match ages
names(mens_fast_lpred) = age_fastest_men

# normalize times
timeNorm_m = cbMen_imp$runTime / mens_fast_lpred[as.character(cbMen_imp$age)]
time99Norm_m = timeNorm_m[cbMen_imp$year == 1999]
time12Norm_m = timeNorm_m[cbMen_imp$year == 2012]

# 1999 age normalized times faster across all quartiles
summary(time99Norm_m)
summary(time12Norm_m)

t.test()

par(mfrow=c(1,2))
plot(density(100*time99Norm_m, na.rm = TRUE), 
    # ylim = c(0, 0.05), 
     col = "purple",
     lwd = 3,  xlab = "Time (percentage)",
     main = "Time Normalized Distribution \n 1999 & 2012 Runners",
     cex.main = 0.8)
lines(density(100*time12Norm_m, na.rm = TRUE), 
          lwd = 3, col = "green")
legend("topleft", fill = c("purple", "green"),
       legend = c("1999", "2012"), bty = "n")

# 2012 age controlled times are definitely slower, 
# runners generally ran slower for their age grps
qqplot(time99Norm_m, time12Norm_m, pch = 19, cex = 0.5, 
       xlab = "Time in 1999 Race",
       ylab = "Time in 2012 Race", 
       main = "QQ Plot of Time Normalized Performance",
       cex.main = 0.8)
abline(a =0, b = 1, col="red", lwd = 2)

# mode of distributions for 1999 peak earlier than 2012
# also tighter spread of times, indicates 1999 faster when
# considering age based times
# qq plot shows distributions are not normal, pull toward 2012
# indicating higher times in 2012 based on age

# for the women

fastestWomen = tapply(cbWomen_imp$runTime, 
                      cbWomen_imp$age,
                      min, 
                      na.rm = FALSE) # we imputed here instead


# convert to numeric
age_fastest_women = as.numeric(names(fastestWomen))
# smooth fastest times by fitting and predicting LOESS
women_fast_lfit = loess(fastestWomen ~ age_fastest_women, span = 0.25)
women_fast_lpred = predict(women_fast_lfit, data.frame(age = age_fastest_women), se = FALSE)
plot(fastestWomen ~ names(fastestWomen), type ="l", xlim = c(20, 80))
lines(x = age_fastest_women, y = women_fast_lpred, col = "purple", lwd = 2)

# normalize times - index on cbWomen$age
# ensure predictions match ages
names(women_fast_lpred) = age_fastest_women
timeNorm_w = cbWomen_imp$runTime / women_fast_lpred[as.character(cbWomen_imp$age)]
time99Norm_w = timeNorm_w[cbWomen_imp$year == 1999]
time12Norm_w = timeNorm_w[cbWomen_imp$year == 2012]

summary(time99Norm_w)
summary(time12Norm_w)

plot(density(100*time99Norm_w, na.rm = TRUE), 
    # ylim = c(0, 0.05), 
     col = "purple",
     lwd = 3,  xlab = "Time (percentage)",
     main = "Time Distribution for 1999 and 2012 Runners\n Percentage of the fastest runner for that age")
lines(density(100*time12Norm_w, na.rm = TRUE), 
          lwd = 3, col = "green")
legend("topleft", fill = c("purple", "green"),
       legend = c("1999", "2012"), bty = "n")

# 2012 age controlled times are definitely slower, 
# runners generally ran slower for their age grps
qqplot(time99Norm_w, time12Norm_w, pch = 19, cex = 0.5, 
       xlab = "Age Normalized Time in 1999 Race",
       ylab = "Age Normalized Time in 2012 Race", 
       main = "Quantile-quantile plot of female runner's performance")
abline(a = 0, b = 1, col="red", lwd = 2)


# COMPARE BOTH GENDERS




```
``` {r following_runners, include=FALSE, eval=FALSE}
#this iterates over a character vector to eliminate beginning blanks, trailing blanks
# and then replace > 1 middle blanks with a single blank

cbMenSub <- cbMen

# clean name to start tracking
trimBlanks = function(charVector) {
  nameClean = gsub("^[[:blank:]]+", "", charVector)
  nameClean = gsub("[[:blank:]]+$", "", nameClean)
  nameClean = gsub("[[:blank:]]+", " ", nameClean)
}

# clean up name
nameClean = trimBlanks(cbMenSub$name)

length(nameClean)

# 43060 unique names, likely someone ran more than once (or we have a lot of the same names!)
length(unique(nameClean))


# cross tab name counts by nesting table()
table(table(nameClean))

# Michael Smith is the most frequent name (30 times!)
head(sort(table(nameClean), decreasing = TRUE), 1)

# let's look into Mr. Smith a bit more
mSmith = cbMenSub[nameClean == "Michael Smith", ]

head(unique(mSmith$home))

# clean up names a bit more
nameClean = tolower(nameClean)

# more Michael Smiths - 33
head( sort(table(nameClean), decreasing = TRUE), 1)

# get rid of extraneous commas and periods
nameClean = gsub("[,.]", "", nameClean)

# cross tab year and names
tabNameYr = table(cbMenSub$year, nameClean)

# 5 similar names in a single year
max(tabNameYr)

class(tabNameYr)

mode(tabNameYr)

names(attributes(tabNameYr))

dim(tabNameYr)

# colnames are the names of runners
head(colnames(tabNameYr), 3)

which( tabNameYr == max(tabNameYr) )

# find indices to get info on who shows up most for one year
which( tabNameYr == max(tabNameYr), arr.ind = TRUE )

indMax = which( tabNameYr == max(tabNameYr), arr.ind = TRUE )

# Michael Brown most common name
colnames(tabNameYr)[indMax[2]]

# add cleaned version of name to DF
cbMenSub$nameClean = nameClean


# approximate a year of birth
cbMenSub$yob = cbMenSub$year - cbMenSub$age

# Fix home in a similar way
homeClean = trimBlanks(tolower(cbMenSub$home))
cbMenSub$homeClean = gsub("[,.]", "", homeClean)

# lets use Michael Brown as an example
vars = c("year", "homeClean", "nameClean", "yob",  "runTime")
mb = which(nameClean == "michael brown") # get michael brown indices
birthOrder = order(cbMenSub$yob[mb]) # get order of birth given MB indices
cbMenSub[mb[birthOrder], vars] # filter df for michael brown based on birth order

# try a first pass of a unique idb by concatenating name and DOB 
cbMenSub$ID = paste(nameClean, cbMenSub$yob, sep = "_")

# how many times do each id appear?
races = tapply(cbMenSub$year, cbMenSub$ID, length)

races8 = names(races)[which(races >= 8)]

# get men with 8 or more races
men8 = cbMenSub[ cbMenSub$ID %in% races8, ]

orderByRunner = order(men8$ID, men8$year)
men8 = men8[orderByRunner, ] # reorder DF based on indices just obtained

# split up df by ID into a list of DFs
men8L = split(men8, men8$ID)
names(men8L) = races8

# how many runners do we have at least 8 obs for?
length(unique(men8$ID))


# we can discard matches if performance varies too much year to year
# there are A LOT of assumptions being made here
gapTime = tapply(men8$runTime, men8$ID,
                 function(t) any(abs(diff(t)) > 20))

gapTime = sapply(men8L, function(df) 
                          any(abs(diff(df$runTime)) > 20))

# 49 runners with gaps of 20m
sum(gapTime)

# get dfs for two runners from list of 8 or more events for runners
lapply(men8L[ gapTime ][1:2], function(df) df[, vars])

# add state into unique ID
homeLen = nchar(cbMenSub$homeClean)

cbMenSub$state = substr(cbMenSub$homeClean, 
                        start = homeLen - 1, stop = homeLen)

# set '06 to NA since no state
cbMenSub$state[cbMenSub$year == 2006] = NA

# reset id including state now
cbMenSub$ID = paste(cbMenSub$nameClean, cbMenSub$yob, 
                    cbMenSub$state, sep = "_")

numRaces = tapply(cbMenSub$year, cbMenSub$ID, length)
races8 = names(numRaces)[which(numRaces >= 8)]
men8 = cbMenSub[ cbMenSub$ID %in% races8, ]
orderByRunner = order(men8$ID, men8$year)
men8 = men8[orderByRunner, ]

# create list of DFs
men8L = split(men8, men8$ID)
names(men8L) = races8

length(races8)

```
``` {r following_runners_analysis, include=FALSE, eval=FALSE}

# set up plotting in a 3x3 grid
groups = 1 + (1:length(men8L) %% 9)

addRunners = function(listRunners, colors, numLty) 
{
  numRunners = length(listRunners)
  colIndx = 1 + (1:numRunners) %% length(colors) # assign colors modulus
  ltys = rep(1:numLty, each = length(colors), length = numRunners) # line types

  mapply(function(df, i) {      
           lines(df$runTime ~ df$age, 
           col = colors[colIndx[i]], lwd = 2, lty = ltys[i])
         }, listRunners, i = 1:numRunners) 
}

colors = c("#e41a1c", "#377eb8","#4daf4a", "#984ea3", 
           "#ff7f00", "#a65628")

# create blank plot, to add lines for each group
invisible(
  sapply(1:9, function(grpId){
    plot( x = 0, y = 0, type = "n",
          xlim = c(20, 80), ylim = c(50, 130),
          xlab = "Age (years)", ylab = "Run Time (minutes)")
     
    addRunners(men8L[ groups == grpId ], colors, numLty = 6) # add in plots
  }) )

# fit linear model to each
fitOne = function(oneRunner, addLine = FALSE, col = "grey") {
  lmOne = lm(runTime ~ age, data = oneRunner)
  if (addLine) 
    lines(x = oneRunner$age, y = predict(lmOne), 
          col = col, lwd = 2, lty = 2)

  ind = floor( (nrow(oneRunner) + 1) / 2)
  res = c(coefficients(lmOne)[2], oneRunner$age[ind],
          predict(lmOne)[ind])
  names(res) = c("ageCoeff", "medAge", "predRunTime")
  return(res)
}


plot( x = 0, y = 0, type = "n",
      xlim = c(20, 80), ylim = c(50, 130),
      xlab = "Age (years)", ylab = "Run Time (minutes)")
     
addRunners(men8L[ groups == 9 ], colors, numLty = 6)
lapply(men8L[groups == 9], fitOne, addLine = TRUE, col = "black")

men8LongFit = lapply(men8L, fitOne)

coeffs = sapply(men8LongFit, "[", "ageCoeff" )
ages = sapply(men8LongFit, "[", "medAge")

longCoeffs = lm(coeffs ~ ages)

summary(longCoeffs)

pdf("CB_LongCoeffs.pdf", width = 10, height = 7)
oldPar = par(mar = c(4.1, 4.1, 1, 1))
plot(coeffs ~ ages, xlab = "Median Age (years)",
     ylab = "Coefficient (minutes per race / year)")
abline(longCoeffs, col = "#984ea3", lwd = 3)
abline(h = 0, col="blue", lwd = 3)
loCoeffs = loess(coeffs ~ ages)
ageV = min(ages):max(ages)
predV = predict(loCoeffs, new = data.frame(ages = ageV))
lines(x = ageV, y = predV, lwd = 3, lty = 2, col = "#4daf4a")
par(oldPar)
dev.off()
```
```{r web_scraping, include=FALSE, echo=FALSE, eval=FALSE}
# Section 2.7 Parsing
#ubase = "http://www.cherryblossom.org/"
#url = paste(ubase, "results/2012/2012cucb10m-m.htm", sep = "")
#doc = htmlParse(url)

# use xpath to get all pre nodes, get nodeset returns a list of all <pre> nodes in a list
#preNode = getNodeSet(doc, "//pre")

# get text value from the node
#txt = xmlValue(preNode[[1]])

#nchar(txt)

# start and end of text
#substr(txt, 1, 50)

#substr(txt, nchar(txt) - 50, nchar(txt))

# split lines by carriage/new line
#els = strsplit(txt, "\\r\\n")[[1]]

# length of text
#length(els)

# first few lines are all header
#els[1:3]

#els[ length(els) ]

# formalize FUN to extract tables from pages for '99 to '12
# 28 pages in total (14 men + 14 women)
#extractResTable =
       # Retrieve data from web site, find preformatted text,
       # return as a character vector.
#function(url)
#{
#  doc = htmlParse(url)
#  preNode = getNodeSet(doc, "//pre")
#  txt = xmlValue(preNode[[1]])
#  
#  els = strsplit(txt, "\r\n")[[1]]
#  if(length(els) == 1){
#    els = strsplit(txt, "\n")[[1]]
#  }
  
#  return(els)
#}

#m2012 = extractResTable(url)

#identical(m2012, els)


# clean up var names, authors are terrible and causes confusion

#url_base = "http://www.cherryblossom.org/"

# get a list of urls from which to extract the data for men's results
#urls = paste(ubase, "results/", 1999:2012, "/",
#             1999:2012, "cucb10m-m.htm", sep = "")

# apply FUN to vector of URLs
#menTables = lapply(urls, extractResTable)

#options(error = recover)
#menTables = lapply(urls, extractResTable)

# these are for browing the recover() debugging mode
#Browse[1]> ls()

#Browse[1]> url

#Browse[1]> length(preNode)

# find that URLs are different depending on the year, great work web devs.


extractResTable =
  #
  # Retrieve data from web site, 
  # find the preformatted text,
  # and write lines or return as a character vector.
  #
  function(url = "http://www.cherryblossom.org/results/2009/09cucb-F.htm",
           year = 1999, sex = "male", file = NULL)
  {
    doc = htmlParse(url)

    if (year == 2000) {
      # Get preformatted text from 4th font element
      # The top file is ill formed so the <pre> search doesn't work.
      ff = getNodeSet(doc, "//font")
      txt = xmlValue(ff[[4]])
      els = strsplit(txt, "\r\n")[[1]]
    }
    
    else if (year == 2000 & sex == "female"){
      pres = getNodeSet(doc, "//p") # for bad HTML
      txt = xmlValue(pres[[1]])
      els = strsplit(txt, "\r\n")[[1]]
      
    }
    
    else if (year == 2009 & sex == "male") {
      # Get preformatted text from <div class="Section1"> element
      # Each line of results is in a <pre> element
      div1 = getNodeSet(doc, "//div[@class='Section1']")
      pres = getNodeSet(div1[[1]], "//pre")
      els = sapply(pres, xmlValue)
    }
    
    else {
      # Get preformatted text from <pre> elements
      pres = getNodeSet(doc, "//pre")
      txt = xmlValue(pres[[1]])
      els = strsplit(txt, "\r\n")[[1]]
      if(length(els) == 1){
                           els = strsplit(txt, "\n")[[1]]
      }
    } 
    
    if (is.null(file)) return(els)
    # Write the lines as a text file.
    writeLines(els, con = file)
  }
```
```{r data_munging, include=FALSE, eval=FALSE}
# Nolan and Temple Lang Ch. 2

url <- "http://www.cherryblossom.org"

# errors out
#m2012 = read.table(file="MenTxt/2012.txt", skip = 8)

els_2011 = readLines("Data/mens2011.txt")
els_2011[1:10]

# try readlines, as we need custom induction logic
# time in 2012 == Net Time
els_2012 = readLines("Data/mens2012.txt")
els_2012[1:10]

# grep to find "===="" starts, rows above it are headers, rows below are data
# get index of line that begins with at least three equal signs
eqIndex = grep("^===", els_2012)
eqIndex

# or using substr
first3 = substr(els_2012, 1, 3)
which(first3 == "===")

# extract the spacer row ("=== ====") and discard earlier rows
spacerRow = els_2012[eqIndex]
headerRow = els_2012[eqIndex - 1] # just spacer row index - 1
body = els_2012[ -(1:eqIndex) ] # get all except for 1 to spacer row

# format header row to lowercase
headerRow = tolower(headerRow)

# finding age: use regexpr to find index 
ageStart = regexpr("ag", headerRow)
ageStart
# begins at 49 and is two characters for the header label (49,50)

# use this index position to get age from body in a char vector
age = substr(body, start = ageStart, stop = ageStart + 1)
head(age)

# convert to numeric and get summary, median age is 35 for male runners in 2012, youngest is 9, 1 NA
summary(as.numeric(age))

# search spacer row for blank spaces to generalize this method instead of relying on header values
blankLocs = gregexpr(" ", spacerRow)
blankLocs
# blankLocs lists the blank locations between each "column" on the spacer row of "=== ===== ======"
# gregexpr searches for a group of matches (much like using () in a regular expression)
# we can use these positions to extract data and header values by determining start and end of columns

# handle the first column, place 0 into the vector to begin
searchLocs = c(0, blankLocs[[1]])

# use mapply() and substr to extract all the columns
# this method iterates over each line in the body
# mapply gives us a way to call a non-vectorized function in a vectorized way
# a great explanation: http://www.studytrails.com/r/core/control_structures_r_apply_functions_2/

values = mapply(substr,      # apply substr
                list(body),  # for each list item in body
                start = searchLocs[ -length(searchLocs)] + 1,   # for each item in start
                stop = searchLocs[ -1 ] - 1)                    # and each item in stop


# encapsulate finding column locations into a FUN
findColLocs = function(spacerRow) {

  spaceLocs = gregexpr(" ", spacerRow)[[1]] # find a group of column locs
  rowLength = nchar(spacerRow)

  if (substring(spacerRow, rowLength, rowLength) != " ")
    return( c(0, spaceLocs, rowLength + 1))
  else return(c(0, spaceLocs))
}

# create FUN to extract certain columns only, all of this is reliant on the spacer row (yikes)
# takes header row, column names, locations of blanks in separator row
selectCols = function(colNames, headerRow, searchLocs) 
{
  sapply(colNames, 
         function(name, headerRow, searchLocs) # for each name in col names
         {
           startPos = regexpr(name, headerRow)[[1]] # find position using regex
           if (startPos == -1) 
             return( c(NA, NA) ) # error catch
    
           index = sum(startPos >= searchLocs) # how many columns including and after?
           c(searchLocs[index] + 1, searchLocs[index + 1] - 1) # get column width as separate entries in a matrix
         },
         headerRow = headerRow, searchLocs = searchLocs ) # satiate the other function here, this is wasteful
}


searchLocs = findColLocs(spacerRow)
ageLoc = selectCols("ag", headerRow, searchLocs) # this function returns the index for the column in a matrix

# use ageLoc result to apply substr in a vectorized fashion (this can be expanded to include multi-columns)
ages = mapply(substr, 
              list(body), 
              start = ageLoc[1,], 
              stop = ageLoc[2, ])

summary(as.numeric(ages))

# now apply to multiple columns
shortColNames = c("name", "home", "ag", "gun", "net", "time")

locCols = selectCols(shortColNames, headerRow, searchLocs)
# call locCols and notice how gun time and net time are NA

values = mapply(substr, 
                list(body), 
                start = locCols[1, ], 
                stop = locCols[2, ])

class(values)

colnames(values) = shortColNames
head(values)

tail(values)[ , 1:3]

# roll all this mess up into a function for modularity
extractVariables = 
function(file, varNames =c("name", "home", "ag", "gun", "net", "time"))
{
  # Find the index of the spacer row with =s
  eqIndex = grep("^===", file)
  
  # Extract the two key rows and the data
  spacerRow = file[eqIndex] 
  headerRow = tolower(file[ eqIndex - 1 ])
  body = file[ -(1 : eqIndex) ]
       
  # Obtain the starting and ending positions of variables
  searchLocs = findColLocs(spacerRow)
  locCols = selectCols(varNames, headerRow, searchLocs)

  values = mapply(substr, 
                  list(body), 
                  start = locCols[1, ], 
                  stop = locCols[2, ])
  
  colnames(values) = varNames
  
  invisible(values)
}

mfilenames = paste("Data/mens", 1999:2012, ".txt", sep = "")
menFiles = lapply(mfilenames, readLines)
names(menFiles) = 1999:2012
sapply(menFiles, length) # check to see if this worked.....

menResMat = lapply(menFiles, extractVariables)
length(menResMat) # 14, good
sapply(menResMat, nrow)  # some nulls fell out but overall data intact

wfilenames = paste("Data/womens", 1999:2012, ".txt", sep = "")
womenFiles = lapply(wfilenames, readLines)
names(womenFiles) = 1999:2012
sapply(womenFiles, length) # readLines worked

# errors out because of missing data in 2001 file!
# womenResMat = lapply(womenFiles, extractVariables)

### The 2001 results for women are missing the === and the column names.
### Can we pick it up from the 2001 men? YES! Make an exercise
#wfilenames = paste("WomenTxt/", 1999:2012, ".txt", sep = "")
#womenTables = lapply(wfilenames, readLines)

# lets append some context... 
womenFiles[[3]] = append(womenFiles[[3]], menFiles[[3]][4:5], after=3)

womenResMat = lapply(womenFiles, extractVariables)
length(womenResMat) # 14, good
sapply(womenResMat, nrow)  # some nulls fell out but overall data intact
```
```{r data_cleaning, include=FALSE, eval=FALSE}
# ADJUSTED AND PART OF MAKE FILE
# keep track of year and sex, clean variables

# use as.numeric to convert age ('ag') in the 2012 matrix
age = as.numeric(menResMat[['2012']][ , 'ag'])
tail(age)

# apply over each matrix, warnings introduced for NAs coerced
age = sapply(menResMat,
             function(x) as.numeric(x[ , 'ag']))




# 2003 and 2006 are wrong, 2003 median age is ~3 years old
# 2006 has first quartile of 3-4 year olds....

#pdf("Images/CB_BoxplotAgeByYr.pdf", width = 8, height = 5)
#oldPar = par(mar = c(4.1, 4.1, 1, 1))
boxplot(age, ylab = "Age", xlab = "Year")
#par(oldPar)
#dev.off()

#age values shifted right one space outside of our respective spacer row boundaries!
head(menFiles[['2003']])

# in 2006, spacing is off to rigt in multiple columns
menFiles[['2006']][2200:2205]


# solve by including blank position
selectCols = function(shortColNames, headerRow, searchLocs) {
  sapply(shortColNames, function(shortName, headerRow, searchLocs){
    startPos = regexpr(shortName, headerRow)[[1]]
    
    if (startPos == -1) return( c(NA, NA) )
    
    index = sum(startPos >= searchLocs)
    c(searchLocs[index] + 1, searchLocs[index + 1]) # get rid of the -1 in the second term
  }, 
  
  headerRow = headerRow, searchLocs = searchLocs )
}

# check to see if this made a difference
menResMat = lapply(menFiles, extractVariables)
#womenResMat = lapply(womenFiles, extractVariables)

# still seeing NAs
age = sapply(menResMat, 
             function(x) as.numeric(x[ , 'ag']))

# much better from an age perspective
# boxplot with mens age first fix after adjusted searchLocs
boxplot(age, ylab = "Age", xlab = "Year")

# now take care of NAs, count for each matrix
sapply(age,  function(x) sum(is.na(x)))

# investigate the 61 NAs in 2001
age2001 = age[["2001"]]

# explore original raw files, we dropped header in our latet file, so need to add index back in to offset
grep("^===", menFiles[['2001']])

badAgeIndex = which(is.na(age2001)) + 5
menFiles[['2001']][ badAgeIndex ]

# scattered throughout file
badAgeIndex

extractVariables = 
function(file, varNames =c("name", "home", "ag", "gun",
                           "net", "time"))
{
  
  # Find the index of the row with =s
  eqIndex = grep("^===", file)
  # Extract the two key rows and the data 
  spacerRow = file[eqIndex] 
  headerRow = tolower(file[ eqIndex - 1 ])
  body = file[ -(1 : eqIndex) ]
  # Remove footnotes and blank rows
  footnotes = grep("^[[:blank:]]*(\\*|\\#)", body)
  if ( length(footnotes) > 0 ) body = body[ -footnotes ]
  blanks = grep("^[[:blank:]]*$", body)
  if (length(blanks) > 0 ) body = body[ -blanks ]
  
  
  # Obtain the starting and ending positions of variables   
  searchLocs = findColLocs(spacerRow)
  locCols = selectCols(varNames, headerRow, searchLocs)
  
  Values = mapply(substr, list(body), start = locCols[1, ], 
                  stop = locCols[2, ])
  colnames(Values) = varNames
  
  return(Values)
}

menResMat = lapply(menFiles, extractVariables)
#womenResMat = lapply(womenFiles, extractVariables)

# address minimum age issues in 2001, 2002 and 2003
which(age2001 < 5)

# find lines corresponding to the indices, age shows zero, hold for analysis
menFiles[['2001']][ which(age2001 < 5) + 5 ]


# time variable creation
charTime = menResMat[['2012']][, 'time']
head(charTime, 5)

tail(charTime, 5)

# use str split on colons to piece them up
timePieces = strsplit(charTime, ":")

timePieces[[1]]

tail(timePieces, 1)

timePieces = sapply(timePieces, as.numeric)

# report time in minutes
runTime = sapply(timePieces, 
                 function(x) {
                   if (length(x) == 2) x[1] + x[2]/60
                   else 60*x[1] + x[2] + x[3]/60
                 })

summary(runTime)

# encapsulte into converTime
convertTime = function(time) {
  timePieces = strsplit(time, ":")
  timePieces = sapply(timePieces, as.numeric)
  sapply(timePieces, function(x) {
                      if (length(x) == 2) x[1] + x[2]/60
                      else 60*x[1] + x[2] + x[3]/60
                      })
}

# create final dataframe for analysis

createDF = 
function(Res, year, sex) 
{
  # Determine which time to use
  useTime = if( !is.na(Res[1, 'net']) )  
              Res[ , 'net']
            else if( !is.na(Res[1, 'gun']) ) 
               Res[ , 'gun']
            else 
               Res[ , 'time']

  # convert time to minutes
  runTime = convertTime(useTime)
  
  Results = data.frame(year = rep(year, nrow(Res)), # fill year into df
                       sex = rep(sex, nrow(Res)), # fill sex into df
                       name = Res[ , 'name'],
                       home = Res[ , 'home'],
                       age = as.numeric(Res[, 'ag']), 
                       runTime = runTime,
                       stringsAsFactors = FALSE)
  invisible(Results)
}

# create men's DF from each matrix
#menDF = mapply(createDF, menResMat, year = 1999:2012,
#               sex = rep("M", 14), SIMPLIFY = FALSE)
# more Nas from time being coerced to NA
#warnings()[ c(1:2, 49:50) ]

sapply(menDF, function(x) sum(is.na(x$runTime)))


# adjust for footnotes in run time and blanks
createDF = function(Res, year, sex) 
{
  # Determine which time to use
  if ( !is.na(Res[1, 'net']) ) useTime = Res[ , 'net']
  else if ( !is.na(Res[1, 'gun']) ) useTime = Res[ , 'gun']
  else useTime = Res[ , 'time']
  
  # Remove # and * and blanks from time
  useTime = gsub("[#\\*[:blank:]]", "", useTime)
  runTime = convertTime(useTime[ useTime != "" ])
  
  # Drop rows with no time
  Res = Res[ useTime != "", ]
  #if(sex=='W'){
  #  
  #  age = gsub("   ", "0  ", Res[,'ag'])
  #  age = gsub("XX "," 0 ", age)
  #  
  #  Res[, 'ag'] = age
  #}
  
  Results = data.frame(year = rep(year, nrow(Res)),
                       sex = rep(sex, nrow(Res)),
                       name = Res[ , 'name'], home = Res[ , 'home'],
                       age = as.numeric(Res[, 'ag']), 
                       runTime = runTime,
                       stringsAsFactors = FALSE)
  invisible(Results)
}

# still a lot of NAs from 2006 with incorrect spacer row!
#menDF = mapply(createDF, menResMat, year = 1999:2012,
#               sex = rep("M", 14), SIMPLIFY = FALSE)

#sapply(menDF, function(x) sum(is.na(x$runTime)))

# FIX 2006
separatorIdx = grep("^===", menFiles[["2006"]])
separatorRow = menFiles[['2006']][separatorIdx]
separatorRowX = paste(substring(separatorRow, 1, 63), " ", 
                      substring(separatorRow, 65, nchar(separatorRow)), 
                      sep = "")
menFiles[['2006']][separatorIdx] = separatorRowX

# FINALLY good to go
menResMat = sapply(menFiles, extractVariables)
menDF = mapply(createDF, menResMat, year = 1999:2012,
               sex = rep("M", 14), SIMPLIFY = FALSE)


# clean 2006 file with bad separator for women as well
separatorIdx = grep("^===", womenFiles[["2006"]])
separatorRow = womenFiles[['2006']][separatorIdx]
separatorRowX = paste(substring(separatorRow, 1, 63), " ", 
                      substring(separatorRow, 65, nchar(separatorRow)), 
                      sep = "")
womenFiles[['2006']][separatorIdx] = separatorRowX

womenResMat = sapply(womenFiles, extractVariables)

# women files have issues with ages of "XX" and "   ", adjusted previous create DF for this issue
womenDF = mapply(createDF, womenResMat, year = 1999:2012,
                 sex = rep("W", 14), SIMPLIFY = FALSE)

# womens files have some missing ages being coerced to NA. 
# Let's fix and insert zeros and take care of later in analysis
# initial analysis shows one age of XX in women's files, need to clean this as well
# implemented in createDF above
# lapply(womenDF, function(x) {x[!complete.cases(x),] })
# sapply(womenResMat, function(x){ sum(x[,'ag'] == "   ")})
# womenResMat[[4]][3261,]


#pdf("CB_BoxplotTimeByYr.pdf", width = 8, height = 5)
boxplot(sapply(menDF, function(x) x$runTime), 
        xlab = "Year", ylab = "Run Time (min)")
#dev.off()

cbMen = do.call(rbind, menDF)
save(cbMen, file = "cbMen.rda")

dim(cbMen)

load("cbMen.rda")

pdf("CB_Overplot.pdf", width = 8, height = 6)
oldPar = par(mar = c(4.1, 4.1, 1, 1))

```